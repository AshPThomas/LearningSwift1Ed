== Mac App

. Create a new Workspace in Xcode (File -> New -> Workspace)

. Save as Notes.xcworkspace

. File -> New  -> Project, OS X -> Application, Cocoa Application
+
Product name: Notes, Language: Swift, Org. name and identifier: whatever you like, Create Document-Based Application = on, Use Core Data = off, include unit and UI tests = both on
+
When saving it, change 'Add to' to the 'Notes' workspace that you just created

[NOTE]
====
UI tests will only work on OS X 10.11 'El Capitan'.
====

. Run the app and you can already create new 'documents' by pressing Cmd-N.

=== The document model

. Open Document.swift
. Add an NSAttributedString property called +text+ - set its default value to the empty attributed string

. Implement +dataOfType+ to convert the string to an NSData containing RTFD and return it (or throw an error)
. Implement +readFromData+ to convert the NSData into an NSAttributedString or throw an error

. Run the app, you can now save and open files - the UI doesn't change yet, we'll do that next

==== A basic UI

. Open Document.xib

. Delete the label

. Add a text view, resize it to fill the window (leaving some margins)
. Select it
. Editor->Resolve Auto Layout Issues->Reset to Suggested Constraints
	. Text view will now resize to fit the window
. Select the Text View (it's a child of the Bordered Scroll View's Clip View)
. Open Bindings inspector
	. Bind Attributed String to File's Owner; model key path = self.text
	
. Run the app; you can now enter and save text, close the document, re-open it; you get free undo and revision control; LOTS of stuff is taken care of for you!

==== Architecting for attachments

. Right now the document class has a single property: 'text'
. It's also stored as a single file
. We want to include attachments, and the easiest way to do that is to create a 'file package' - this means we won't have to read the entire thing into memory, which might be a problem if those attachments are large
. This means we need to use NSFileWrapper

	. An NSFileWrapper is an object that represents either a single file, or a directory of multiple files (each of which can itself be a file wrapper representing a directory)
	. In this app we'll use directory file wrappers; they'll contain at least two files:
		 . A file that contains general info about the document, named "Document.plist"
		 . The .rtfd file containing the text, called "Text.rtfd"
		 . Plus any attached files, which will be kept in a directory called Attachments (so that you can drop files with any name in, including ones named "Document.plist" and "Text.rtf")

. This means we need to implement methods that load from and save to a file wrapper

. Go to project -> Info, scroll down to Document Types, turn on Document is distributed as a bundle

. Implement +readFromFileWrapper+ and +fileWrapperOfType+ (plus related funcs and enums)

. Re-run the app, make a document, save it
. Locate that document in the Finder and right click, choose Show Package Contents - behold, Text.rtf!

==== Adding attachments

. Now we'll add support for actually storing attachments

. First we'll add the collection view
. Resize the text view to make room for the collection view at the bottom
. Add a collection view


. Add a new cocoa class - subclass of NSViewController, turn on create XIB file, name it AddAttachmentViewController

. Open the xib, add a button for File attachments and the label 'Add a new...' above it

. Open the Document xib, add a + button (use a gradient button), attach it to a new method called +addAttachment+; make sure the parameter is of type NSButton and not AnyObject!
. Add a new property: +popover+, optional NSPopover
. Implement addAttachment

. Open AddAttachmentViewController.swift 
. Add the +AddAttachmentDelegate+ protocol
. Add a new property, +delegate+, type: optional +AddAttachmentDelegate+
. Attach the File button to a new method that calls the delegate's +addFile+ method

. Implement +addFile+
. Implement +addAttachmentAtURL+

. Run the app, add an attachment, save the document, view package contents - it's there!


==== Adding support for QuickLook

==== iCloud

. Go to Project Settings, General tab
. Ensure that you've set your Team correctly
. Go to Capabilities tab
. Turn on iCloud, wait for it to load
. Turn on iCloud documents, set Container to "Specify custom containers", add a new container called iCloud.<your bundle ID> - this is to allow your iOS app to access the same container

. Open Info.plist

. Add the following stuff:

----
<key>NSUbiquitousContainers</key>
    <dict>
        <key>iCloud.YOUR.BUNDLE.IDENTIFIER</key>
        <dict>
            <key>NSUbiquitousContainerIsDocumentScopePublic</key>
            <true/>
            <key>NSUbiquitousContainerSupportedFolderLevels</key>
            <string>Any</string>
            <key>NSUbiquitousContainerName</key>
            <string>Notes</string>
        </dict>
    </dict>
----

[NOTE]
====
Run +brctl log --wait --shorten+ in the terminal to get a log of everything iCloud is doing
====

== iOS App

=== Starting up and adding iCloud

. File -> New -> Target, iOS single-view application, name it Notes-iOS, set it up as a universal app, ensure core data= OFF
. Add it to the workspace

. Project settings -> Notes-iOS target -> Capabilities
	. Enable iCloud 
	. iCloud documents = on
	. Specify custom containers
	. Use the same container as the one you created for the OS X app
	
	

	
. Open AppDelegate.swift
. Add code that queries +URLForUbiquityContainerIdentifier+

. Open iOS simulator
. Go to Settings->iCloud
. Create a new Apple ID (do NOT use your current one) and sign into it

ALTERNATIVELY

. Install it on your phone, as long as your phone is signed into iCloud

. Go back to Xcode and run the app; after a few seconds, it will log the location of the container!

=== Creating the list view controller

. Open the storyboard and delete everything
. Add a new navigation controller; delete the table view that it comes with
. Make the navigation controller the initial view controller
. Drag out a Collection View Controller
. Make the collection view controller be the root view controller of the navigation controller
. Set its class to +ViewController+
. Open ViewController.swift
. Change +ViewController+ to subclass +UICollectionViewController+
. Add the +FileCollectionViewCell+ class to ViewController.swift

. Select the cell, change its class to +FileCollectionViewCell+, set its reuse identifier to +FileCell+
. Add a label to the cell, constrain it to the center-bottom of the cell
. Add a view above the label that takes up the rest of the space
. Connect the label to the +fileNameLabel+ property of +FileCollectionViewCell+


=== Listing documents

. We need to subclass UIDocument and create the equivalent of the Document class from the Mac app for the iOS app
. Several important things need to be the same across the two different classes - the names of files for example
. We'll move them into a separate swift file that's part of both targets
. Right click the project, add a new group, name it Common
	. Select this new group and go to the file inspector, click on the little folder icon to set its location, an open dialog box will appear; in it, make a new folder called Common, and then click Choose
	. You've just made a new folder to put files that are common to both projects!
. Right click the Common group and add a new Swift file
	. Name it DocumentCommon, and add it to both the Notes and Notes-iOS targets by checking the boxes
	. Open the Document.swift file and move the +err+ func, and all three enums into DocumentCommons.swift
	. Check that the Mac app still builds!
	
. Create a new Cocoa Touch class in Notes-iOS, subclass of UIDocument

. Add +NSAttributedString+ property +text+, defaults to the empty attributed string
. Add +NSFileWrapper+ property +documentFileWrapper+, defaults to an empty directory file wrapper
. Implement +loadFromContents+ to load the text (ignoring anything to do with attachments for now)
. Implement +contentsForType+ to store the text

. Time to start LISTING documents:
	. Add +metadataQuery+, +queryDidFinishGatheringObserver+ and +queryDidUpdateObserver+ properties
	. Make +viewDidLoad+ set up the observers and kick off the query
	. Implement +queryUpdated+, to make it refresh the table view
	. Implement +numberOfSectionsInCollectionView+, +numberOfItemsInSection+, and +cellForItemAtIndexPath+
	. Run the app! If there are documents in the container

. Now we can start CREATING documents

. Implement the +localDocumentsDirectoryURL+ lazy property - this gives us the folder to store our local documents in
. Implement the +ubiquitousDocumentsDirectoryURL+ lazy property - this gives us the location of where to put documents in order for them to be in iCloud
. Implement the +createDocument+ function

. Run the app, click the + button, and you'll be adding new files! You're a winner!

==== Downloading from iCloud

. First we need to show files that aren't yet downloaded
. Implement +itemIsOpenable+
. Add checks in +cellForItemAtIndexPath+ to make unavailable documents transparent

. Update +queryUpdated+ to begin downloading any files that aren't already down

=== Opening documents

. New UIViewController subclass called +DocumentViewController+
. Add a new view controller to the storyboard, set its class to +DocumentViewController+
. Connect it to the document list view controller via a segue called ShowDocument
. Add a +UITextView+ to it, make it fill the screen and set it to Attributed (instead of Plain) 

. Open +DocumentViewController+
	. Implement +textView+, +document+, +documentURL+ properties
	. Implement +viewWillAppear+ to open the document
	
. Connect the text view to the +textView+ outlet

. In ViewController.swift:
	. Implement +didSelectItemAtIndexPath+
	. Implement +prepareForSegue+
	
. Run the app, make a document, it works!

=== Editing and saving documents

. Make DocumentViewController conform to UITextViewDelegate
. Implement +textViewDidChange+ to store text in the document and update change count
. In the storyboard, make the Document View Controller the text view's delegate
. Implement +viewWillDisappear+ to close the document
. Launch the app, open a document, make changes, close it, re-open it, the changes are still there!

=== Handling conflicts

=== UI for attachments

=== 